# Food Chilling Log GraphQL Schema

# Global auth rule for testing - in production you'll want more specific auth rules
input AMPLIFY { globalAuthRule: AuthRule = { allow: public } } # FOR TESTING ONLY!

# User model for employees, supervisors, and admins
type User @model {
  id: ID!
  initials: String!
  name: String!
  role: UserRole!
  certificationNumber: String
  email: String
  isActive: Boolean!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
  logEntries: [LogEntry] @hasMany(indexName: "byEmployee", fields: ["id"])
}

# Paper Form Entry model for food chilling logs
type PaperFormEntry @model {
  id: ID!
  date: AWSDateTime!
  formType: FormType!
  formInitial: String!
  status: FormStatus!
  title: String
  
  # Row entries (1-9)
  entries: [PaperFormRow!]!
  
  # Bottom section
  thermometerNumber: String
  ingredients: Ingredients
  lotNumbers: LotNumbers
  correctiveActionsComments: String
  
  # Admin comments and resolution
  adminComments: [AdminComment!]
  resolvedErrors: [String!]
  
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

# Paper Form Row for individual entries
type PaperFormRow {
  type: String
  
  # CCP 1 - Temperature Must reach 166°F or greater
  ccp1: StageData
  # CCP 2 - 127°F or greater
  ccp2: StageData
  # 80°F or below within 105 minutes
  coolingTo80: StageData
  # 54°F or below within 4.75 hr
  coolingTo54: StageData
  # Chill Continuously to 39°F or below
  finalChill: StageData
}

# Ingredients information
type Ingredients {
  beef: String
  chicken: String
  liquidEggs: String
}

# Lot numbers information
type LotNumbers {
  beef: String
  chicken: String
  liquidEggs: String
}

# Admin comment for paper forms
type AdminComment {
  id: ID!
  adminInitial: String!
  timestamp: AWSDateTime!
  comment: String!
}

# Log entry model for food chilling records
type LogEntry @model {
  id: ID!
  date: AWSDateTime!
  shift: Shift!
  
  # Product Information
  product: String!
  productCode: String
  supplier: String
  receivedDate: AWSDateTime
  expirationDate: AWSDateTime
  thermometerNumber: String!
  lotNumber: String!
  batchSize: Int
  packagingType: String
  
  # Employee Information
  employeeId: ID! @index(name: "byEmployee")
  employeeName: String!
  employeeInitials: String!
  supervisorInitials: String
  employee: User @belongsTo(fields: ["employeeId"])
  
  # Cooking & Cooling Stages
  cookStage: StageData
  startCoolingStage: StageData
  to80Stage: StageData
  to54Stage: StageData
  finalChillStage: StageData
  
  # HACCP Documentation
  ccp1Verified: Boolean!
  ccp2Verified: Boolean!
  monitoringCompleted: Boolean!
  correctiveActionsDocumented: Boolean!
  
  # Quality Control
  visualInspectionColor: InspectionResult!
  visualInspectionTexture: InspectionResult!
  visualInspectionOdor: InspectionResult!
  visualInspectionNotes: String
  
  # Storage Information
  storageLocation: String!
  storageTemperature: Float
  storageTime: AWSDateTime
  
  # Workflow Status
  currentStage: StageType!
  isComplete: Boolean!
  requiresReview: Boolean!
  isApproved: Boolean
  adminComments: String
  reviewedBy: String
  reviewDate: AWSDateTime
  
  # Compliance
  complianceIssues: [String]
  riskLevel: RiskLevel!
  
  # Signatures & Timestamps
  employeeSignature: String
  supervisorSignature: String
  adminSignature: String
  completedAt: AWSDateTime
  submittedAt: AWSDateTime
  
  # Additional Documentation
  photos: [String]
  attachments: [String]
  notes: String
  
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

# Stage data embedded type
type StageData {
  temperature: Float
  time: AWSDateTime
  isValid: Boolean
  correctiveAction: String
  employeeInitials: String
  notes: String
}

# Initial entry model for managing employee initials
type InitialEntry @model {
  id: ID!
  initials: String!
  name: String!
  isActive: Boolean!
  createdBy: String!
  createdAt: AWSDateTime!
  updatedAt: AWSDateTime!
}

# Enums
enum UserRole {
  EMPLOYEE
  SUPERVISOR
  ADMIN
}

enum Shift {
  MORNING
  AFTERNOON
  EVENING
  OVERNIGHT
}

enum StageType {
  COOK
  START_COOLING
  TO_80
  TO_54
  FINAL_CHILL
}

enum FormType {
  FOOD_CHILLING_LOG
}

enum FormStatus {
  COMPLETE
  IN_PROGRESS
  ERROR
}

enum InspectionResult {
  NORMAL
  ABNORMAL
}

enum RiskLevel {
  LOW
  MEDIUM
  HIGH
}

# Custom input types for mutations
input StageDataInput {
  temperature: Float
  time: AWSDateTime
  isValid: Boolean
  correctiveAction: String
  employeeInitials: String
  notes: String
}

input PaperFormRowInput {
  type: String
  ccp1: StageDataInput
  ccp2: StageDataInput
  coolingTo80: StageDataInput
  coolingTo54: StageDataInput
  finalChill: StageDataInput
}

input IngredientsInput {
  beef: String
  chicken: String
  liquidEggs: String
}

input LotNumbersInput {
  beef: String
  chicken: String
  liquidEggs: String
}

input AdminCommentInput {
  id: ID!
  adminInitial: String!
  timestamp: AWSDateTime!
  comment: String!
}

input CreatePaperFormEntryInput {
  id: ID
  date: AWSDateTime!
  formType: FormType!
  formInitial: String!
  status: FormStatus!
  title: String
  entries: [PaperFormRowInput!]!
  thermometerNumber: String
  ingredients: IngredientsInput
  lotNumbers: LotNumbersInput
  correctiveActionsComments: String
  adminComments: [AdminCommentInput!]
  resolvedErrors: [String!]
}

input UpdatePaperFormEntryInput {
  id: ID!
  date: AWSDateTime
  formType: FormType
  formInitial: String
  status: FormStatus
  title: String
  entries: [PaperFormRowInput!]
  thermometerNumber: String
  ingredients: IngredientsInput
  lotNumbers: LotNumbersInput
  correctiveActionsComments: String
  adminComments: [AdminCommentInput!]
  resolvedErrors: [String!]
}

input CreateLogEntryInput {
  id: ID
  date: AWSDateTime!
  shift: Shift!
  product: String!
  productCode: String
  supplier: String
  receivedDate: AWSDateTime
  expirationDate: AWSDateTime
  thermometerNumber: String!
  lotNumber: String!
  batchSize: Int
  packagingType: String
  employeeId: ID!
  employeeName: String!
  employeeInitials: String!
  supervisorInitials: String
  cookStage: StageDataInput
  startCoolingStage: StageDataInput
  to80Stage: StageDataInput
  to54Stage: StageDataInput
  finalChillStage: StageDataInput
  ccp1Verified: Boolean!
  ccp2Verified: Boolean!
  monitoringCompleted: Boolean!
  correctiveActionsDocumented: Boolean!
  visualInspectionColor: InspectionResult!
  visualInspectionTexture: InspectionResult!
  visualInspectionOdor: InspectionResult!
  visualInspectionNotes: String
  storageLocation: String!
  storageTemperature: Float
  storageTime: AWSDateTime
  currentStage: StageType!
  isComplete: Boolean!
  requiresReview: Boolean!
  isApproved: Boolean
  adminComments: String
  reviewedBy: String
  reviewDate: AWSDateTime
  complianceIssues: [String]
  riskLevel: RiskLevel!
  employeeSignature: String
  supervisorSignature: String
  adminSignature: String
  completedAt: AWSDateTime
  submittedAt: AWSDateTime
  photos: [String]
  attachments: [String]
  notes: String
}

input UpdateLogEntryInput {
  id: ID!
  date: AWSDateTime
  shift: Shift
  product: String
  productCode: String
  supplier: String
  receivedDate: AWSDateTime
  expirationDate: AWSDateTime
  thermometerNumber: String
  lotNumber: String
  batchSize: Int
  packagingType: String
  employeeId: ID
  employeeName: String
  employeeInitials: String
  supervisorInitials: String
  cookStage: StageDataInput
  startCoolingStage: StageDataInput
  to80Stage: StageDataInput
  to54Stage: StageDataInput
  finalChillStage: StageDataInput
  ccp1Verified: Boolean
  ccp2Verified: Boolean
  monitoringCompleted: Boolean
  correctiveActionsDocumented: Boolean
  visualInspectionColor: InspectionResult
  visualInspectionTexture: InspectionResult
  visualInspectionOdor: InspectionResult
  visualInspectionNotes: String
  storageLocation: String
  storageTemperature: Float
  storageTime: AWSDateTime
  currentStage: StageType
  isComplete: Boolean
  requiresReview: Boolean
  isApproved: Boolean
  adminComments: String
  reviewedBy: String
  reviewDate: AWSDateTime
  complianceIssues: [String]
  riskLevel: RiskLevel
  employeeSignature: String
  supervisorSignature: String
  adminSignature: String
  completedAt: AWSDateTime
  submittedAt: AWSDateTime
  photos: [String]
  attachments: [String]
  notes: String
}

# Custom queries
type Query {
  # Get logs by date range
  getLogsByDateRange(startDate: AWSDateTime!, endDate: AWSDateTime!): [LogEntry]
  
  # Get today's logs
  getTodaysLogs: [LogEntry]
  
  # Get logs requiring review
  getLogsRequiringReview: [LogEntry]
  
  # Get logs by employee
  getLogsByEmployee(employeeId: ID!): [LogEntry]
  
  # Get logs by shift
  getLogsByShift(shift: Shift!): [LogEntry]
  
  # Paper Form queries
  getPaperFormsByDateRange(startDate: AWSDateTime!, endDate: AWSDateTime!): [PaperFormEntry]
  getTodaysPaperForms: [PaperFormEntry]
  getPaperFormsByStatus(status: FormStatus!): [PaperFormEntry]
  getPaperFormsByInitial(initial: String!): [PaperFormEntry]
}

# Custom mutations
type Mutation {
  # Update stage data for a log entry
  updateLogEntryStage(
    logEntryId: ID!
    stage: StageType!
    stageData: StageDataInput!
  ): LogEntry
  
  # Submit log entry for review
  submitLogEntryForReview(logEntryId: ID!): LogEntry
  
  # Approve log entry (admin only)
  approveLogEntry(
    logEntryId: ID!
    adminComments: String
    adminSignature: String
  ): LogEntry
  
  # Add corrective action
  addCorrectiveAction(
    logEntryId: ID!
    stage: StageType!
    action: String!
    employeeInitials: String!
  ): LogEntry
  
  # Paper Form mutations
  updatePaperFormStatus(
    formId: ID!
    status: FormStatus!
  ): PaperFormEntry
  
  addAdminComment(
    formId: ID!
    comment: AdminCommentInput!
  ): PaperFormEntry
  
  resolveError(
    formId: ID!
    errorId: String!
  ): PaperFormEntry
}

# Subscriptions for real-time updates
type Subscription {
  onLogEntryCreated: LogEntry
    @aws_subscribe(mutations: ["createLogEntry"])
  
  onLogEntryUpdated: LogEntry
    @aws_subscribe(mutations: ["updateLogEntry"])
  
  onLogEntrySubmittedForReview: LogEntry
    @aws_subscribe(mutations: ["submitLogEntryForReview"])
  
  # Paper Form subscriptions
  onPaperFormEntryCreated: PaperFormEntry
    @aws_subscribe(mutations: ["createPaperFormEntry"])
  
  onPaperFormEntryUpdated: PaperFormEntry
    @aws_subscribe(mutations: ["updatePaperFormEntry"])
  
  onPaperFormStatusUpdated: PaperFormEntry
    @aws_subscribe(mutations: ["updatePaperFormStatus"])
}